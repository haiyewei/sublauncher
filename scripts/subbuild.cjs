const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

const rootDir = path.resolve(__dirname, '..'); // 项目根目录
const subDir = path.join(rootDir, 'sub'); // 子项目目录，用于克隆和构建
const publicDir = path.join(rootDir, 'public'); // 最终静态文件目录
const subprojectsConfigFile = path.join(rootDir, 'subprojects.json');
const gitignoreFile = path.join(rootDir, '.gitignore');
const redirectsFile = path.join(rootDir, '_redirects');

// 递归复制文件夹及其内容
function copyFolderRecursiveSync(source, target) {
  // 检查目标文件夹是否存在，如果不存在则创建
  if (!fs.existsSync(target)) {
    fs.mkdirSync(target, { recursive: true });
  }

  // 读取源文件夹中的所有文件和文件夹
  const files = fs.readdirSync(source);

  // 遍历所有文件和文件夹
  files.forEach(file => {
    const sourcePath = path.join(source, file);
    const targetPath = path.join(target, file);

    // 检查当前项是文件还是文件夹
    const stat = fs.statSync(sourcePath);

    if (stat.isDirectory()) {
      // 递归复制子文件夹
      copyFolderRecursiveSync(sourcePath, targetPath);
    } else {
      // 复制文件
      fs.copyFileSync(sourcePath, targetPath);
    }
  });
}

// 修复HTML文件中的资源路径引用
function fixAssetPathsInHtml(htmlFilePath, projectName) {
  console.log(`Fixing asset paths in ${htmlFilePath} for project ${projectName}...`);
  
  try {
    let htmlContent = fs.readFileSync(htmlFilePath, 'utf-8');
    
    // 1. 修复 script 标签中的 src 属性引用 - 只替换绝对路径但不以项目名开头的路径
    htmlContent = htmlContent.replace(/src=["']\/(?!([^"']*\/)?assets\/)/g, (match) => {
      return match.replace(/src=["']\//g, `src="/${projectName}/`);
    });
    
    // 2. 修复 link 标签中的 href 属性引用 - 只替换绝对路径但不以项目名开头的路径
    htmlContent = htmlContent.replace(/href=["']\/(?!([^"']*\/)?assets\/)/g, (match) => {
      return match.replace(/href=["']\//g, `href="/${projectName}/`);
    });
    
    // 3. 修复其他潜在的资源引用 - 只替换绝对路径但不以项目名开头的路径
    htmlContent = htmlContent.replace(/content=["']\/(?!([^"']*\/)?assets\/)/g, (match) => {
      return match.replace(/content=["']\//g, `content="/${projectName}/`);
    });
    
    // 4. 避免修复已经用绝对URL开头的路径
    // 修复 URL("/path") 这样的引用（可能存在于内联CSS中）
    htmlContent = htmlContent.replace(/url\(["']\/(?!([^"']*\/)?assets\/)/g, (match) => {
      return match.replace(/url\(["']\//g, `url("/${projectName}/`);
    });
    
    // 5. 确保所有相对路径的资源引用都是正确的
    // 替换 src="assets/... 为 src="/projectName/assets/...
    htmlContent = htmlContent.replace(/src=["']assets\//g, `src="/${projectName}/assets/`);
    htmlContent = htmlContent.replace(/href=["']assets\//g, `href="/${projectName}/assets/`);
    htmlContent = htmlContent.replace(/url\(["']assets\//g, `url("/${projectName}/assets/`);
    
    // 写回修改后的内容
    fs.writeFileSync(htmlFilePath, htmlContent, 'utf-8');
    console.log(`Successfully updated asset paths in ${htmlFilePath}`);
  } catch (error) {
    console.error(`Error fixing asset paths in ${htmlFilePath}:`, error.message);
  }
}

// 更新.gitignore文件，添加子项目的public目录
function updateGitignore(projectNames) {
  console.log('Updating .gitignore file with sub-project public directories...');
  
  try {
    if (!fs.existsSync(gitignoreFile)) {
      console.warn('.gitignore file not found, creating new one...');
      fs.writeFileSync(gitignoreFile, '# Auto-generated by subbuild.cjs\n');
    }
    
    let gitignoreContent = fs.readFileSync(gitignoreFile, 'utf-8');
    
    // 查找子项目注释标记
    const subProjectsMarker = '# Sub projects (auto-generated)';
    let subProjectsSection = '';
    
    // 移除已存在的子项目部分（如果有的话）
    if (gitignoreContent.includes(subProjectsMarker)) {
      // 保留标记前的内容
      gitignoreContent = gitignoreContent.split(subProjectsMarker)[0].trim() + '\n\n';
      subProjectsSection = subProjectsMarker + '\n';
    } else {
      // 如果没有标记，在文件末尾添加空行和标记
      if (!gitignoreContent.endsWith('\n')) {
        gitignoreContent += '\n';
      }
      gitignoreContent += '\n' + subProjectsMarker + '\n';
      subProjectsSection = '';
    }
    
    // 为每个子项目添加public目录忽略规则
    projectNames.forEach(projectName => {
      subProjectsSection += `/public/${projectName}/\n`;
    });
    
    // 将更新后的内容写回文件
    fs.writeFileSync(gitignoreFile, gitignoreContent + subProjectsSection);
    console.log('Successfully updated .gitignore file');
  } catch (error) {
    console.error('Error updating .gitignore file:', error.message);
  }
}

function runCommand(command, cwd, env = {}) {
  console.log(`\nExecuting in ${cwd || rootDir}: ${command}`);
  try {
    execSync(command, { stdio: 'inherit', cwd: cwd || rootDir, env: { ...process.env, ...env } });
    return true;
  } catch (error) {
    console.error(`\nError executing command: ${command}`);
    console.error(error.message);
    return false;
  }
}

// 处理主页方式的枚举
const MainPageMode = {
  USE_QWIK: 'use_qwik',           // 使用Qwik原生主页
  REDIRECT: 'redirect',           // 重定向到默认项目
  DISABLED: 'disabled'            // 禁用主页
};

// 创建主页重定向文件
function createMainPageRedirect(defaultProject) {
  const indexHtmlPath = path.join(publicDir, 'index.html');
  
  // 如果文件已存在，先删除
  if (fs.existsSync(indexHtmlPath)) {
    try {
      fs.unlinkSync(indexHtmlPath);
      console.log(`Removed existing index.html file.`);
    } catch (error) {
      console.error(`Error removing existing index.html file:`, error.message);
    }
  }
  
  // 使用服务端重定向而不是客户端JavaScript重定向
  // 这样可以避免模块加载问题
  const redirectContent = `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta http-equiv="refresh" content="0;url=/${defaultProject}/">
  <title>Redirecting to ${defaultProject}</title>
  <script>
    // 确保重定向后的页面能正确加载模块
    window.addEventListener('DOMContentLoaded', function() {
      // 获取当前URL的路径部分
      const path = window.location.pathname;
      // 如果已经在子项目页面，不执行重定向
      if (path.startsWith('/${defaultProject}/')) {
        // 阻止meta refresh重定向
        const meta = document.querySelector('meta[http-equiv="refresh"]');
        if (meta) meta.remove();
      } else {
        // 使用完整的URL进行重定向，避免相对路径问题
        window.location.href = window.location.origin + '/${defaultProject}/';
      }
    });
  </script>
</head>
<body>
  <p>Redirecting to <a href="/${defaultProject}/">${defaultProject}</a>...</p>
</body>
</html>`;

  fs.writeFileSync(indexHtmlPath, redirectContent);
  console.log(`Created redirect index.html to ${defaultProject}`);
}

// 创建禁用主页的空白页面
function createDisabledMainPage() {
  const indexHtmlPath = path.join(publicDir, 'index.html');
  
  // 如果文件已存在，先删除
  if (fs.existsSync(indexHtmlPath)) {
    try {
      fs.unlinkSync(indexHtmlPath);
      console.log(`Removed existing index.html file.`);
    } catch (error) {
      console.error(`Error removing existing index.html file:`, error.message);
    }
  }
  
  const disabledContent = `<!DOCTYPE html>\n<html>\n<head>\n  <meta charset="UTF-8">\n  <title>主页已禁用</title>\n  <style>\n    body {\n      font-family: sans-serif;\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      height: 100vh;\n      margin: 0;\n      background-color: #f5f5f5;\n    }\n    .container {\n      text-align: center;\n      padding: 2rem;\n      background-color: white;\n      border-radius: 8px;\n      box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n    }\n    h1 {\n      color: #333;\n    }\n    p {\n      color: #666;\n    }\n  </style>\n</head>\n<body>\n  <div class="container">\n    <h1>主页已禁用</h1>\n    <p>请直接访问子项目路径</p>\n  </div>\n</body>\n</html>`;

  fs.writeFileSync(indexHtmlPath, disabledContent);
  console.log(`Created disabled main page index.html`);
}

// 获取主页处理模式
function getMainPageMode(settings, defaultProject) {
  // 情况3：禁用主页 - 当disableMainPage为true时，忽略defaultProject
  if (settings.disableMainPage === true) {
    return {
      mode: MainPageMode.DISABLED
    };
  }
  
  // 情况2：使用配置文件指定的默认项目作为重定向目标
  // 当disableMainPage为false，且defaultProject存在有效的项目值(不为null或undefined)
  if (defaultProject && defaultProject !== "null" && defaultProject !== "undefined") {
    return {
      mode: MainPageMode.REDIRECT,
      project: defaultProject
    };
  }
  
  // 情况1：使用Qwik原生主页
  // 当disableMainPage为false，且defaultProject的值为null或不存在
  return {
    mode: MainPageMode.USE_QWIK
  };
}

// 生成_redirects文件
function generateRedirects(projects) {
  console.log('Generating _redirects file from projects configuration...');
  
  let redirectsContent = '';
  
  // 为每个项目添加重定向规则
  projects.forEach(project => {
    if (project.name) {
      // 确保静态资源直接通过，不做重定向处理
      redirectsContent += `/${project.name}/assets/* /${project.name}/assets/:splat 200\n`;
      // 同样要保证JavaScript文件不会被重定向干扰
      redirectsContent += `/${project.name}/*.js /${project.name}/:splat 200\n`;
      redirectsContent += `/${project.name}/*.css /${project.name}/:splat 200\n`;
      // 其他路径使用标准重定向
      redirectsContent += `/${project.name}/* /${project.name}/:splat 200\n`;
    }
  });
  
  // 写入_redirects文件
  fs.writeFileSync(redirectsFile, redirectsContent);
  console.log('Generated _redirects file with the following content:');
  console.log(redirectsContent);
}

function main() {
  if (!fs.existsSync(subprojectsConfigFile)) {
    console.error(`Error: Configuration file not found at ${subprojectsConfigFile}`);
    console.error('Please create subprojects.json in the project root.');
    process.exit(1);
  }

  let config;
  try {
    const configFileContent = fs.readFileSync(subprojectsConfigFile, 'utf-8');
    config = JSON.parse(configFileContent);
  } catch (error) {
    console.error(`Error reading or parsing ${subprojectsConfigFile}:`, error.message);
    process.exit(1);
  }

  // 确保配置格式正确
  if (!config.projects || !Array.isArray(config.projects) || config.projects.length === 0) {
    console.log(`No projects found in ${subprojectsConfigFile} or the file format is invalid. Nothing to do.`);
    return;
  }

  // 获取设置
  const settings = config.settings || {};
  const defaultProject = settings.defaultProject || (config.projects[0] ? config.projects[0].name : null);

  // 确保 sub 目录存在
  if (!fs.existsSync(subDir)) {
    console.log(`Creating sub directory at: ${subDir}`);
    fs.mkdirSync(subDir, { recursive: true });
  }

  // 确保 public 目录存在
  if (!fs.existsSync(publicDir)) {
    console.log(`Creating public directory at: ${publicDir}`);
    fs.mkdirSync(publicDir, { recursive: true });
  }
  
  // 用于收集所有处理的项目名称
  const processedProjects = [];

  // 处理每个项目
  for (const project of config.projects) {
    if (!project.name || !project.repoUrl) {
      console.warn('\nSkipping invalid project entry (missing name or repoUrl):', JSON.stringify(project));
      continue;
    }

    const projectName = project.name;
    processedProjects.push(projectName);
    
    const repoUrl = project.repoUrl;
    const commitHash = project.commitHash;
    const rootPath = project.root || ''; // 子项目中的根目录，如果未指定则为空
    const projectPath = path.join(subDir, projectName); // 克隆到的目录路径
    
    // 确定实际的工作目录（根据是否指定了root）
    const workingPath = rootPath ? path.join(projectPath, rootPath) : projectPath;
    
    const buildOutputPath = project.buildOutput || 'dist'; // 默认使用 dist 作为构建输出目录
    const publicProjectPath = path.join(publicDir, projectName);

    console.log(`\nProcessing project: ${projectName} from ${repoUrl}`);
    if (commitHash) {
      console.log(`Target commit: ${commitHash}`);
    }
    if (rootPath) {
      console.log(`Using root directory: ${rootPath}`);
    }
    console.log(`Project path: ${projectPath}`);
    console.log(`Working path: ${workingPath}`);
    console.log(`Build output will be copied from: ${path.join(workingPath, buildOutputPath)}`);
    console.log(`Files will be moved to: ${publicProjectPath}`);

    // 克隆或更新代码
    if (fs.existsSync(projectPath)) {
      console.log(`Directory ${projectPath} already exists.`);
      if (fs.existsSync(path.join(projectPath, '.git'))) {
        console.log('Fetching latest changes...');
        runCommand('git fetch', projectPath);
        if (commitHash) {
          console.log(`Checking out commit: ${commitHash}`);
          runCommand(`git checkout ${commitHash}`, projectPath);
        } else {
          console.log('Checking out default branch and pulling latest changes...');
          // Attempt to checkout main, then master, then pull
          if (!runCommand('git checkout main', projectPath)) {
             runCommand('git checkout master', projectPath); // Fallback to master
          }
          runCommand('git pull', projectPath);
        }
      } else {
        console.log(`No .git directory found in ${projectPath}. Skipping update. If a specific commit is needed, delete the directory and re-run.`);
      }
    } else {
      console.log(`Cloning repository into ${projectPath}...`);
      runCommand(`git clone ${repoUrl} "${projectName}"`, subDir);
      if (commitHash && fs.existsSync(path.join(projectPath, '.git'))) {
        console.log(`Checking out commit: ${commitHash}`);
        runCommand(`git checkout ${commitHash}`, projectPath);
      }
    }
    
    // 检查工作目录是否存在
    if (!fs.existsSync(workingPath)) {
      console.error(`Working directory ${workingPath} does not exist. Check your 'root' path configuration.`);
      continue;
    }

    // 安装依赖并构建 - 使用指定的工作目录
    const packageJsonPath = path.join(workingPath, 'package.json');
    if (fs.existsSync(packageJsonPath)) {
      console.log(`Installing dependencies for ${projectName} in ${workingPath}...`);
      runCommand('npm install', workingPath);
      
      // 运行构建命令
      console.log(`Building ${projectName}...`);
      const buildSuccess = runCommand('npm run build', workingPath);
      
      if (buildSuccess) {
        // 检查构建输出目录是否存在
        const buildOutputDir = path.join(workingPath, buildOutputPath);
        if (fs.existsSync(buildOutputDir)) {
          // 确保目标目录存在
          if (!fs.existsSync(publicProjectPath)) {
            fs.mkdirSync(publicProjectPath, { recursive: true });
          } else {
            // 如果目标目录已存在，先清空它
            console.log(`Cleaning existing files in ${publicProjectPath}...`);
            try {
              fs.rmSync(publicProjectPath, { recursive: true, force: true });
              fs.mkdirSync(publicProjectPath, { recursive: true });
            } catch (error) {
              console.error(`Error cleaning directory ${publicProjectPath}:`, error.message);
            }
          }
          
          // 复制构建结果到 public 目录
          console.log(`Copying build output from ${buildOutputDir} to ${publicProjectPath}...`);
          copyFolderRecursiveSync(buildOutputDir, publicProjectPath);
          console.log(`Successfully copied build files for ${projectName}`);
          
          // 修复入口文件中的资源路径
          const indexHtmlPath = path.join(publicProjectPath, 'index.html');
          if (fs.existsSync(indexHtmlPath)) {
            fixAssetPathsInHtml(indexHtmlPath, projectName);
          } else {
            console.log(`No index.html found in ${publicProjectPath}. Skipping asset path fixes.`);
          }
        } else {
          console.error(`Build output directory ${buildOutputDir} not found for ${projectName}. Skipping copy step.`);
        }
      } else {
        console.error(`Build failed for ${projectName}. Skipping copy step.`);
      }
    } else {
      console.log(`No package.json found in ${workingPath}. Skipping dependency installation and build.`);
    }

    console.log(`\nProject ${projectName} processing complete.`);
    console.log(`If your main project is running (e.g., via npm run dev),`);
    console.log(`you should be able to access this sub-project at: /${projectName}/`);
  }

  // 处理主页
  const mainPageConfig = getMainPageMode(settings, defaultProject);
  console.log('\n处理主页...');
  
  switch (mainPageConfig.mode) {
    case MainPageMode.REDIRECT:
      console.log(`主页模式: 重定向到默认项目 ${mainPageConfig.project}`);
      createMainPageRedirect(mainPageConfig.project);
      break;
    case MainPageMode.DISABLED:
      console.log('主页模式: 禁用主页');
      createDisabledMainPage();
      break;
    case MainPageMode.USE_QWIK:
      console.log('主页模式: 使用Qwik原生主页');
      // 不做任何处理，保留原有的index.html
      // 如果 public/index.html 不存在，则不创建
      if (!fs.existsSync(path.join(publicDir, 'index.html'))) {
        console.log('警告: 未找到Qwik主页文件，您可能需要运行 npm run build 来生成它');
      }
      break;
  }
  
  // 更新.gitignore文件，添加所有子项目目录
  updateGitignore(processedProjects);

  // 生成_redirects文件
  generateRedirects(config.projects);

  console.log('\nAll specified sub-projects processed from subprojects.json.');
  console.log('Static files have been placed in the public directory.');
}

main(); 